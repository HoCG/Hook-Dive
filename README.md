# Hook-Dive
숨참고 훅 다이브🤿


## useEffect
  스테이트의 값이 변할때마다, 그리고 넘겨받은 props값이 변경될 때마다 자연스럽게 useEffect가 동작하게 된다. 그리고 화면이 마운트, 언마운트 되는 시점에서 실행된다는 점. useEffect뒤에 배열을 넣어줄 수가 있다. 빈배열의 경우 마운트가 되는 시점에만, 그리고 배열안에 값을 넣으면 넣은 값이 변경될때에만 useEffect가 실행되도록 할 수 있다. useEffect안에 return을 두는 경우는 unMount의 효과를 기대할 수 있다. 들 수 있는 예시는 인터벌이 있을 것이다. 인터벌을 계속 지정해둔 경우 clean을 해줄때까지 동작을 하게된다. 이런 문제를 방지하고자 unMount시에 clean을 할 수 있도록 해주는 것이다.

## useReducer
위에 useEffect를 쓰다가 문득 그런생각이 들때가 있을 것이다. "set~~~함수를 통해 상태를 수정할때에 복잡한 상태의 값 변화를 반복적으로 계산해줘야만 하는가?"라는 의문이다. 물론 함수화를 통해 문제를 해결할 수 있지만 state를 위해서 따로 함수를 만들고 state관리를 돕는다? 그건 뭔가 합리적이지 못하다는 생각이 든다. 이 문제를 해결하기위해서 우리는 useReducer라는 훅을 사용할것이다. 정말정말 쉽게 해당 훅을 묘사해보자면 로컬 state 전용 redux이다. useReducer와 redux의 코드가 정말 비슷하게 생겼기 때문이다. 각 action에 따른 switch case를 정의하고 리턴되는 값을 정의한다. 이때 정말 좋은점은 다양한 경우를 고려해서 값을 만들어낼 수 있다는 점이다. create, update, delete, read 모두 구현이 가능하다. 그리고 이로인해 코드를 좀 더 직관적이게 만들어 줄 수 있다는 점도 내겐 굉장한 매력으로 와닿았다!

근데 이런생각도 할 수 있을 듯하다. 그냥 리덕스쓰면 되는거 아닌가? 라는 생각인데 리덕스는 엄밀히 전역 상태관리 라이브러리이며 꼭 필요한 상황이 아니라면 사용을 자중하는게 좋다. (다양한 전역상태를 계속 생각해주면서 개발에 임하기에는 머리가 너무 아프기 때문. 우리가 전역변수 사용을 자제하는 이유를 생각해보자.) 근데 로컬 상태값들을 관리만 하면 되지만 리덕스처럼 다양하게 상태변화를 주고싶다면 과감히 useReducer를 사용해보자아아


## useMemo

useEffect안에 리렌더링이 될때마다 특정 값을 계속해서 바꿔줘야하는 상황이 있을텐데, 만약 특정값을 계산하는게 무척 복잡하고 시간복잡도를 많이 잡아먹는다고 가정해보자. 이 경우 useEffect가 실행될때마다 계산이 이루어져야하기 때문에 시간복잡도가 높은 연산을 계속 실행하게 된다. 이 상황을 방지하고자 특정값이 변할때에만 리렌더링되길 바란다? 이때에는 바로 useMemo를 통해 성능 최적화를 해보자. useMemo는 메모리상에 계산되어야하는 값을 저장해두고 특정 값이 바뀔때에만 실행되도록 만들 수 있다.


자 그리고 memo도 한번 알아보자. 우리가 일반적으로 생각해봤을때 자식 컴포넌트의 리렌더링이 일어난다면 부모는 당연히 리렌더링이 발생하지 않는다. 그러나 부모가 리렌더링이 발생시 자식도 리렌더링이 발생하게 되는데 특정상황에서 자식과 부모가 독립적으로 렌더가 되길 바란다면 이는 비효율적인 방식이라고 결론이 난다. 우리는 그래서 memo를 통해서 이러한 상황을 방지할 수 있다. memo를 React에서 import한 후에 자식컴포넌트를 감싸도록 한다면, 부모의 리렌더링이 일어나는 시점에서 자식의 리렌더링을 막을 수 있는 것이다.
이렇게 훌륭한 useMemo와 memo도 문제점이 하나있는데 바로 메모리를 차지한다는 점이다. 이 일련의 과정들은 메모리에 값이나 컴포넌트를 저장하기 때문에 일어날 수 있는 것이다. 따라서 반드시 useMemo, memo를 써야하는 상황에서만 사용하도록 하자.


## useCallback

## useRef

## useContext

## useQuery

## useMutation

## customHook
